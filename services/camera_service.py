# =======================================================================================
# üìÑ Dosya Adƒ±   : camera_service.py
# üìÅ Konum       : guard_pc/services/camera_service.py
# üìå A√ßƒ±klama    : Kamera g√∂r√ºnt√º yakalama ve d√º≈üme tespit sistemi
#                 - Kamera baƒülantƒ±sƒ± ve g√∂r√ºnt√º yakalama
#                 - Ger√ßek zamanlƒ± d√º≈üme tespiti
#                 - Tespit sonrasƒ± otomatik bildirim ve kayƒ±t
#
# üîó Baƒülantƒ±lƒ± Dosyalar:
#   - models/fall_detector.py   : D√º≈üme tespit modeli
#   - services/database_service.py : Olay kaydetme
#   - services/storage_service.py  : Ekran g√∂r√ºnt√ºs√º kaydetme
#   - services/notification_service.py : Bildirim g√∂nderme
#   - config/settings.py        : Kamera ayarlarƒ±
# =======================================================================================

import logging
import cv2
import numpy as np
import time
import threading
from typing import Optional, Callable, Dict, Tuple
from datetime import datetime

from config.settings import Settings
from models.fall_detector import get_fall_detector
from services.database_service import get_database_service
from services.storage_service import get_storage_service

class CameraService:
    """Kamera ve g√∂r√ºnt√º i≈üleme servisi"""
    
    def __init__(self, user_id: str = None):
        """
        Args:
            user_id (str): Mevcut kullanƒ±cƒ±nƒ±n ID'si
        """
        self.user_id = user_id
        self.camera = None
        self.is_running = False
        self.is_detecting = False
        
        # Kamera ayarlarƒ±
        self.camera_index = Settings.CAMERA_INDEX
        self.camera_width = Settings.CAMERA_WIDTH
        self.camera_height = Settings.CAMERA_HEIGHT
        self.camera_fps = Settings.CAMERA_FPS
        
        # G√∂r√ºnt√º i≈üleme
        self.current_frame = None
        self.processed_frame = None
        self.frame_lock = threading.Lock()
        
        # Tespit sistemi
        self.fall_detector = get_fall_detector()
        self.database_service = get_database_service()
        self.storage_service = get_storage_service()
        
        # Callback fonksiyonlarƒ±
        self.frame_callback = None
        self.detection_callback = None
        self.error_callback = None
        
        # Performans takibi
        self.fps_counter = 0
        self.fps_start_time = time.time()
        self.current_fps = 0.0
        
        # Thread kontrol
        self.capture_thread = None
        self.processing_thread = None
        
        logging.info("CameraService ba≈ülatƒ±ldƒ±")
    
    def set_user_id(self, user_id: str):
        """Kullanƒ±cƒ± ID'sini ayarlar"""
        self.user_id = user_id
        logging.info(f"Kullanƒ±cƒ± ID ayarlandƒ±: {user_id}")
    
    def set_callbacks(self, frame_callback: Callable = None, 
                     detection_callback: Callable = None,
                     error_callback: Callable = None):
        """Callback fonksiyonlarƒ±nƒ± ayarlar"""
        self.frame_callback = frame_callback
        self.detection_callback = detection_callback
        self.error_callback = error_callback
        logging.info("Callback fonksiyonlarƒ± ayarlandƒ±")
    
    def initialize_camera(self) -> bool:
        """Kamerayƒ± ba≈ülatƒ±r"""
        try:
            if self.camera is not None:
                self.release_camera()
            
            logging.info(f"Kamera ba≈ülatƒ±lƒ±yor - Index: {self.camera_index}")
            
            # Kamerayƒ± a√ß
            self.camera = cv2.VideoCapture(self.camera_index)
            
            if not self.camera.isOpened():
                logging.error(f"Kamera a√ßƒ±lamadƒ± - Index: {self.camera_index}")
                return False
            
            # Kamera ayarlarƒ±nƒ± yapƒ±landƒ±r
            self.camera.set(cv2.CAP_PROP_FRAME_WIDTH, self.camera_width)
            self.camera.set(cv2.CAP_PROP_FRAME_HEIGHT, self.camera_height)
            self.camera.set(cv2.CAP_PROP_FPS, self.camera_fps)
            
            # Buffer boyutunu azalt (d√º≈ü√ºk gecikme i√ßin)
            self.camera.set(cv2.CAP_PROP_BUFFERSIZE, 1)
            
            # Test frame'i al
            ret, test_frame = self.camera.read()
            if not ret or test_frame is None:
                logging.error("Test frame'i alƒ±namadƒ±")
                return False
            
            # Ger√ßek ayarlarƒ± al
            actual_width = int(self.camera.get(cv2.CAP_PROP_FRAME_WIDTH))
            actual_height = int(self.camera.get(cv2.CAP_PROP_FRAME_HEIGHT))
            actual_fps = self.camera.get(cv2.CAP_PROP_FPS)
            
            logging.info(f"Kamera ba≈üarƒ±yla a√ßƒ±ldƒ± - √á√∂z√ºn√ºrl√ºk: {actual_width}x{actual_height}, FPS: {actual_fps}")
            return True
            
        except Exception as e:
            logging.error(f"Kamera ba≈ülatƒ±lƒ±rken hata: {str(e)}")
            if self.error_callback:
                self.error_callback(f"Kamera hatasƒ±: {str(e)}")
            return False
    
    def start_capture(self) -> bool:
        """G√∂r√ºnt√º yakalamayƒ± ba≈ülatƒ±r"""
        try:
            if self.is_running:
                logging.warning("G√∂r√ºnt√º yakalama zaten √ßalƒ±≈üƒ±yor")
                return True
            
            if not self.fall_detector.is_loaded:
                logging.info("Fall detector y√ºkleniyor...")
                if not self.fall_detector.load_model():
                    logging.error("Fall detector y√ºklenemedi")
                    return False
            
            if self.camera is None:
                if not self.initialize_camera():
                    return False
            
            self.is_running = True
            
            # G√∂r√ºnt√º yakalama thread'ini ba≈ülat
            self.capture_thread = threading.Thread(target=self._capture_loop, daemon=True)
            self.capture_thread.start()
            
            # G√∂r√ºnt√º i≈üleme thread'ini ba≈ülat
            self.processing_thread = threading.Thread(target=self._processing_loop, daemon=True)
            self.processing_thread.start()
            
            logging.info("G√∂r√ºnt√º yakalama ba≈ülatƒ±ldƒ±")
            return True
            
        except Exception as e:
            logging.error(f"G√∂r√ºnt√º yakalama ba≈ülatƒ±lƒ±rken hata: {str(e)}")
            return False
    
    def stop_capture(self):
        """G√∂r√ºnt√º yakalamayƒ± durdurur"""
        try:
            if not self.is_running:
                return
            
            logging.info("G√∂r√ºnt√º yakalama durduruluyor...")
            self.is_running = False
            
            # Thread'lerin bitmesini bekle
            if self.capture_thread and self.capture_thread.is_alive():
                self.capture_thread.join(timeout=2.0)
            
            if self.processing_thread and self.processing_thread.is_alive():
                self.processing_thread.join(timeout=2.0)
            
            logging.info("G√∂r√ºnt√º yakalama durduruldu")
            
        except Exception as e:
            logging.error(f"G√∂r√ºnt√º yakalama durdurulurken hata: {str(e)}")
    
    def _capture_loop(self):
        """G√∂r√ºnt√º yakalama d√∂ng√ºs√º (ayrƒ± thread'de √ßalƒ±≈üƒ±r)"""
        try:
            while self.is_running and self.camera is not None:
                ret, frame = self.camera.read()
                
                if not ret or frame is None:
                    logging.warning("Frame alƒ±namadƒ±")
                    time.sleep(0.1)
                    continue
                
                # Frame'i g√ºvenli ≈üekilde kaydet
                with self.frame_lock:
                    self.current_frame = frame.copy()
                
                # FPS hesapla
                self._update_fps()
                
                # Frame callback'ini √ßaƒüƒ±r
                if self.frame_callback:
                    try:
                        self.frame_callback(frame.copy())
                    except Exception as callback_error:
                        logging.error(f"Frame callback hatasƒ±: {str(callback_error)}")
                
                # CPU kullanƒ±mƒ±nƒ± azaltmak i√ßin kƒ±sa bekle
                time.sleep(Settings.DETECTION_INTERVAL)
                
        except Exception as e:
            logging.error(f"Capture loop hatasƒ±: {str(e)}")
            if self.error_callback:
                self.error_callback(f"Kamera hatasƒ±: {str(e)}")
    
    def _processing_loop(self):
        """G√∂r√ºnt√º i≈üleme d√∂ng√ºs√º (ayrƒ± thread'de √ßalƒ±≈üƒ±r)"""
        try:
            while self.is_running:
                # Mevcut frame'i al
                with self.frame_lock:
                    if self.current_frame is None:
                        time.sleep(0.1)
                        continue
                    
                    frame_to_process = self.current_frame.copy()
                
                # D√º≈üme tespiti yap
                if self.is_detecting and self.user_id:
                    detection_result = self.fall_detector.detect_fall(frame_to_process)
                    
                    # Tespit sonu√ßlarƒ±nƒ± g√∂r√ºnt√º √ºzerine √ßiz
                    self.processed_frame = self.fall_detector.draw_detections(frame_to_process, detection_result)
                    
                    # D√º≈üme tespit edildiyse
                    if detection_result["fall_detected"]:
                        self._handle_fall_detection(frame_to_process, detection_result)
                    
                    # Detection callback'ini √ßaƒüƒ±r
                    if self.detection_callback:
                        try:
                            self.detection_callback(detection_result, self.processed_frame)
                        except Exception as callback_error:
                            logging.error(f"Detection callback hatasƒ±: {str(callback_error)}")
                else:
                    self.processed_frame = frame_to_process
                
                time.sleep(Settings.DETECTION_INTERVAL)
                
        except Exception as e:
            logging.error(f"Processing loop hatasƒ±: {str(e)}")
    
    def _handle_fall_detection(self, frame: np.ndarray, detection_result: Dict):
        """D√º≈üme tespiti sonrasƒ± i≈ülemleri yapar"""
        try:
            event_id = str(int(time.time() * 1000))  # Unique event ID
            
            logging.warning(f"D√ú≈ûME TESPƒ∞T EDƒ∞LDƒ∞! - Event ID: {event_id}, G√ºven: {detection_result['confidence']:.2f}")
            
            # Ekran g√∂r√ºnt√ºs√ºn√º kaydet
            screenshot_url = self.storage_service.upload_screenshot(
                user_id=self.user_id,
                image=frame,
                event_id=event_id
            )
            
            # Olay verisini hazƒ±rla
            event_data = {
                "id": event_id,
                "user_id": self.user_id,
                "timestamp": time.time(),
                "created_at": time.time(),
                "confidence": detection_result["confidence"],
                "detection_count": detection_result["detection_count"],
                "detections": detection_result["detections"],
                "screenshot_url": screenshot_url,
                "location": "PC Kamerasƒ±",  # Sabit konum
                "status": "detected",
                "processed": False
            }
            
            # Veritabanƒ±na kaydet
            success = self.database_service.save_fall_event(self.user_id, event_data)
            
            if success:
                logging.info(f"D√º≈üme olayƒ± kaydedildi - Event ID: {event_id}")
                
                # Bildirim g√∂nder (ayrƒ± thread'de)
                threading.Thread(
                    target=self._send_notifications,
                    args=(event_data,),
                    daemon=True
                ).start()
            else:
                logging.error("D√º≈üme olayƒ± kaydedilemedi")
                
        except Exception as e:
            logging.error(f"D√º≈üme tespiti i≈ülenirken hata: {str(e)}")
    
    def _send_notifications(self, event_data: Dict):
        """Bildirimleri g√∂nderir (ayrƒ± thread'de √ßalƒ±≈üƒ±r)"""
        try:
            # Notification service import burada yapƒ±yoruz (circular import √∂nlemek i√ßin)
            from services.notification_service import get_notification_service
            
            notification_service = get_notification_service()
            notification_service.send_fall_alert(self.user_id, event_data)
            
        except Exception as e:
            logging.error(f"Bildirim g√∂nderilirken hata: {str(e)}")
    
    def _update_fps(self):
        """FPS hesaplar"""
        self.fps_counter += 1
        
        if self.fps_counter >= 30:  # Her 30 frame'de bir hesapla
            current_time = time.time()
            elapsed_time = current_time - self.fps_start_time
            
            if elapsed_time > 0:
                self.current_fps = self.fps_counter / elapsed_time
            
            self.fps_counter = 0
            self.fps_start_time = current_time
    
    def start_detection(self):
        """D√º≈üme tespitini ba≈ülatƒ±r"""
        if not self.user_id:
            logging.error("D√º≈üme tespiti i√ßin kullanƒ±cƒ± ID gerekli")
            return False
        
        if not self.fall_detector.is_loaded:
            logging.error("Fall detector y√ºklenmemi≈ü")
            return False
        
        self.is_detecting = True
        logging.info("D√º≈üme tespiti ba≈ülatƒ±ldƒ±")
        return True
    
    def stop_detection(self):
        """D√º≈üme tespitini durdurur"""
        self.is_detecting = False
        logging.info("D√º≈üme tespiti durduruldu")
    
    def get_current_frame(self) -> Optional[np.ndarray]:
        """Mevcut frame'i d√∂nd√ºr√ºr"""
        with self.frame_lock:
            return self.current_frame.copy() if self.current_frame is not None else None
    
    def get_processed_frame(self) -> Optional[np.ndarray]:
        """ƒ∞≈ülenmi≈ü frame'i d√∂nd√ºr√ºr"""
        return self.processed_frame.copy() if self.processed_frame is not None else None
    
    def capture_screenshot(self) -> Optional[np.ndarray]:
        """Manuel ekran g√∂r√ºnt√ºs√º alƒ±r"""
        with self.frame_lock:
            if self.current_frame is not None:
                return self.current_frame.copy()
        return None
    
    def get_camera_info(self) -> Dict:
        """Kamera bilgilerini d√∂nd√ºr√ºr"""
        if self.camera is None:
            return {"status": "disconnected"}
        
        try:
            width = int(self.camera.get(cv2.CAP_PROP_FRAME_WIDTH))
            height = int(self.camera.get(cv2.CAP_PROP_FRAME_HEIGHT))
            fps = self.camera.get(cv2.CAP_PROP_FPS)
            
            return {
                "status": "connected" if self.is_running else "stopped",
                "width": width,
                "height": height,
                "fps": fps,
                "current_fps": self.current_fps,
                "is_detecting": self.is_detecting
            }
            
        except Exception as e:
            logging.error(f"Kamera bilgileri alƒ±nƒ±rken hata: {str(e)}")
            return {"status": "error", "error": str(e)}
    
    def release_camera(self):
        """Kamerayƒ± serbest bƒ±rakƒ±r"""
        try:
            if self.camera is not None:
                self.camera.release()
                self.camera = None
                logging.info("Kamera serbest bƒ±rakƒ±ldƒ±")
        except Exception as e:
            logging.error(f"Kamera serbest bƒ±rakƒ±lƒ±rken hata: {str(e)}")
    
    def cleanup(self):
        """T√ºm kaynaklarƒ± temizler"""
        try:
            self.stop_capture()
            self.release_camera()
            
            # Fall detector'ƒ± temizle
            if self.fall_detector:
                self.fall_detector.cleanup()
            
            logging.info("CameraService temizlendi")
            
        except Exception as e:
            logging.error(f"Cleanup sƒ±rasƒ±nda hata: {str(e)}")

# Global camera service instance'ƒ±
_camera_service_instance = None

def get_camera_service() -> CameraService:
    """Global CameraService instance'ƒ±nƒ± d√∂nd√ºr√ºr"""
    global _camera_service_instance
    if _camera_service_instance is None:
        _camera_service_instance = CameraService()
    return _camera_service_instance

def initialize_camera_service(user_id: str) -> CameraService:
    """Kamera servisini kullanƒ±cƒ± ID'si ile ba≈ülatƒ±r"""
    camera_service = get_camera_service()
    camera_service.set_user_id(user_id)
    return camera_service